FRAM (Ferroelectric Random Access Memory) is used for both program memory and data memory (like in the MSP430FR6989). It replaces Flash (program memory), SRAM (volatile data memory) and EEPROM (non-volatile data memory) memories inside a microcontroller.
 
XOR (^) is used extensively in C programs for microcontrollers to toggle a specific bit. NOT (~) cannot be used to invert only specific bits in the number. When a bit is XORed with a 0, it does not change. When a bit is XORed with a 1, it is inverted.

The data bus is typically 8-, 16-, or 32-bits wide. You will often hear microcontrollers described as 8-bit, 16-bit, or 32-bit devices. This is a description of how wide the data bus is on the microcontroller and how many bits the Arithmetic Logic Unit can process at one time.

float - Approximately 7 digits of precision. double - Approximately 15 digits of precision.

Do not use float/double variables unless absolutely necessary. While they are comparable in size to the other variables types, float variables are much more difficult for your microcontroller to manipulate. If you use even one float operation (like addition), your program may grow by several kilobytes.

Use a smaller variable type to hold smaller values.

CCS will default char (without a further designation of signed or unsigned) to unsigned char variables (stores 0 to 255).

CCS will default int (without a further designation of signed or unsigned) to signed int variables (stores -32,768 to +32,767).

In a signed char 127 + 1 = -128 and -128 - 1 = 127

++a Pre-increment the variable a before it is used in your instruction
a++ Post-increment the variable a after it is used in your instruction

x = ++a;	a = a + 1;
		x = a;

x = a++;	x = a;
		a = a + 1;

--a Pre-decrement
a-- Post-decrement

A good way to remember the difference between pre- and post- is that if the  notation comes before the  variable, it will be incremented/decremented before anything else in the instruction. If the notation comes after the variable, it will increment/decrement after the rest of the instruction has evaluated.

WDTCTL, Watchdog Timer+ Register:
Bits 15-8	WDTPW	Watchdog timer+ password. Always read as 069h. Must be written as 05Ah, or a PUC is generated.
Bit 7		WDTHOLD	Watchdog timer+ hold. This bit stops the watchdog timer+. Setting WDTHOLD = 1 when the WDT+ is not in use conserves power.
		0 Watchdog timer+ is not stopped
		1 Watchdog timer+ is stopped

MSP430G2553 doesn't have a Power Management Module (PMM). There isn't a Port I/O Control by a Power Mode Control Register (Like MSP430FR6989 PM5CTL0 - Power Mode 5 Control Register 0).

P1DIR Register - Port P1 direction

P1OUT Register - Port P1 output

P1REN Register - Port P1 resistor enable

Input Register PxIN:
Each bit in each PxIN register reflects the value of the input signal at the corresponding I/O pin when the pin is configured as I/O function.
	Bit = 0: The input is low
	Bit = 1: The input is high

Output Registers PxOUT:
Each bit in each PxOUT register is the value to be output on the corresponding I/O pin when the pin is configured as I/O function, output direction, and the pullup/down resistor is disabled.
	Bit = 0: The output is low
	Bit = 1: The output is high

If the pin's pullup/pulldown resistor is enabled, the corresponding bit in the PxOUT register selects pullup or pulldown.
	Bit = 0: The pin is pulled down
	Bit = 1: The pin is pulled up

Direction Registers PxDIR:
Each bit in each PxDIR register selects the direction of the corresponding I/O pin, regardless of the selected function for the pin. PxDIR bits for I/O pins that are selected for other functions must be set as required by the other function.
	Bit = 0: The port pin is switched to input direction
	Bit = 1: The port pin is switched to output direction

Pullup/Pulldown Resistor Enable Registers PxREN:
Each bit in each PxREN register enables or disables the pullup/pulldown resistor of the corresponding I/O pin. The corresponding bit in the PxOUT register selects if the pin is pulled up or pulled down.
	Bit = 0: Pullup/pulldown resistor disabled
	Bit = 1: Pullup/pulldown resistor enabled

All of the pins are defaulted to be inputs (PxDIR = 0b00000000;).

If the value is non-zero, it is always taken as true.

#define BIT0 0x01
#define BIT1 0x02
#define BIT2 0x04
#define BIT3 0x08
#define BIT4 0x10
#define BIT5 0x20
#define BIT6 0x40
#define BIT7 0x80 // BIT0 to BIT7 already defined by <msp430.h> like WDTPW and WDTHOLD

P1DIR = P1DIR | BIT0;
P1DIR = P1DIR | BIT4;
P1DIR = P1DIR | BIT7;		// Or: P1DIR = P1DIR | (BIT7 + BIT4 + BIT0);

PxDIR = PxDIR | BITy;

break statement can be used to immediately exit a for or while loop.

continue statemente can be used to jump iterations of for or while loop.

The watchdog timer is a peripheral that can be used to restart your program if it becomes unresponsive. Therefore, if you create a program with the WDT enabled, you have to 'pet' or reset the count on the watchdog to let it know your program is running fine.

WDTCTL is a 16-bit register.

WatchDog Timer CouNTer Clear (WDTCNTCL). You need to make this bit HI to pet the watchdog and start it counting again.

The watchdog peripheral is enabled automatically when the program starts running. That's why we have to disable it for every program. Therefore, to use the watchdog in your program, you don't really have to enable it or start it running.


General Purpose Timer Up mode is probably sufficient for 95% of the developers, 95% of the time.

Two 16-Bit timer/counter (Timer_A TA0 TA1) With Three Capture/Compare Registers

The timer has four modes of operation: stop, up, continuous, and up/down. The operating mode is selected with the TACTL MC bits:

00 Stop - The timer is halted.
01 Up - The timer repeatedly counts from zero to the value of TACCR0
10 Continuous - The timer repeatedly counts from zero to 0FFFFh.
11 Up/down - The timer repeatedly counts from zero up to the value of TACCR0 and back down to zero.

The timer repeatedly counts up to the value of compare register TACCR0.

Timer A ConTroL Register (TACTL): 
Bit 9-8 - TASSEL - Timer_A clock source select
00b = TAxCLK (externally)
01b = ACLK (Auxiliary clock)
10b = SMCLK (Subsystem master clock)
11b = INCLK (INCLK is device-specific and is often assigned to the inverted TBCLK) (see the device specific
data sheet)

Bit 7-6 - ID - Input divider. These bits select the divider for the input clock.
00b = /1
01b = /2
10b = /4
11b = /8

Bit 0 - TAIFG - Timer_A interrupt flag
0b = No interrupt pending
1b = Interrupt pending

The clock source is selected with the TASSEL bits. The selected clock source may be passed directly to the timer or
divided by 2, 4, or 8, using the ID bits.

TACCRn Register - Timer_A Capture/Compare n Register
Bit 15-0 - TACCR0 - Compare mode: TACCRn holds the data for the comparison to the timer value in the Timer_A Register, TAR.
Capture mode: The Timer_A Register, TAR, is copied into the TACCRn register when a capture is performed.

General purpose timer means that it can count from 0x0000 up to 0xFFFF (or 0 to 65535 decimal).

There are a lot of different ways that TACCRn can be used, but in the UP mode  that we are using, the  peripheral is going to compare its count value to the number you store in it.


After a PUC, MCLK and SMCLK are sourced from DCOCLK at ~1.1 MHz (see the device-specific data
sheet for parameters) and ACLK is sourced from LFXT1CLK in LF mode with an internal load capacitance
of 6 pF.

• ACLK: Auxiliary clock. ACLK is software selectable as LFXT1CLK or VLOCLK. ACLK is divided by 1,
2, 4, or 8. ACLK is software selectable for individual peripheral modules.
• SMCLK: Sub-main clock. SMCLK is software selectable as LFXT1CLK, VLOCLK, XT2CLK (if available
on-chip), or DCOCLK. SMCLK is divided by 1, 2, 4, or 8. SMCLK is software selectable for individual
peripheral modules.

For optimal low-power performance, ACLK
can be sourced from a low-power 32768-Hz watch crystal (if available), providing a stable time base for
the system and low-power standby operation, or from the internal low-frequency oscillator when crystal accurate
time keeping is not required. The MCLK can be configured to operate from the on-chip DCO that
can be activated when requested by interrupt-driven events. The SMCLK can be configured to operate
from a crystal or the DCO, depending on peripheral requirements. A flexible clock distribution and divider
system is provided to fine tune the individual clock requirements.

The internal very-low-power low-frequency oscillator (VLO) provides a typical frequency of 12 kHz (see
device-specific data sheet for parameters) without requiring a crystal. VLOCLK source is selected by
setting LFXT1Sx = 10 when XTS = 0. The OSCOFF bit disables the VLO for LPM4. The LFXT1 crystal
oscillators are disabled when the VLO is selected reducing current consumption. The VLO consumes no
power when not being used.

After a PUC, RSELx = 7 and DCOx = 3, allowing the DCO to start at a mid-range frequency. MCLK and
SMCLK are sourced from DCOCLK.

The LFXT1 oscillator supports ultra-low current consumption using a 32768-Hz watch crystal in LF mode
(XTS = 0). A watch crystal connects to XIN and XOUT without any other external components. The
software-selectable XCAPx bits configure the internally provided load capacitance for the LFXT1 crystal in
LF mode. This capacitance can be selected as 1 pF, 6 pF, 10 pF, or 12.5 pF typical. Additional external
capacitors can be added if necessary.

BCSCTL2, Basic Clock System Control Register 2
DIVSx - Bits 2-1 - Divider for SMCLK
00 /1
01 /2 2h
10 /4 4h
11 /8 6h

When people use the Watchdog Timer peripheral, they use one of their timers to count up for a pre-defined internal, and then pet the watchdog  when the timer reaches its count value. Timers are not quite as accurate as we would like, so it is always good to leave some margin for error. Most modern microcontrollers have multiple timers. One is often used for the watchdog timer and general 'upkeep' tasks your microcontroller must periodically perform.

Watchdog Mode
After a PUC condition, the WDT+ module is configured in the watchdog mode with an initial 32768 cycle reset interval using the DCOCLK. 

(Watchdog clock source) / [1100000 (DCOCLK) / 8 (BCSCTL2 DIVSx)] = 32768 / 137500 = 0,238313 = 238 ms

WDTCTL, Watchdog Timer+ Register
WDTISx - Bits 1-0 (00) - Watchdog timer+ interval select. These bits select the watchdog timer+ interval to set the WDTIFG flag and/or generate a PUC.
00 Watchdog clock source /32768
01 Watchdog clock source /8192
10 Watchdog clock source /512
11 Watchdog clock source /64

The function prototype tells your program that a function exists and will be defined later. If you don't have a prototype (or a definition before main) and try to use the function, an error will occur. You can declare as many function prototypes as you need.

You can omit the word void from your function prototype and function definitions. This is commonly done.

No matter how many functions you may add to your C program, the execution will always start at the beginning of main().

Most of the time we use functions, our programs will be slightly larger. However, most developers are willing to suffer a small increase in program size for the convenience of using functions.

Your function may have as many different return statements as you want, but as soon as the program executes one of the return statements, the program will immediatelly leave your function and return to main() (or from wherever your function was called).

ISR Interrupt Service Rountine

You need to enable your peripheral to use an interrupt. For the gerneral purpose timers on the MSP430, this is accomplished with a single additional instruction: TA0CCTL0 = CCIE;

TACCTLx, Capture/Compare Control Register

CCIE - Bit 4 - Capture/compare interrupt enable. This bit enables the interrupt request of the corresponding CCIFG flag.
0 Interrupt disabled
1 Interrupt enabled

Second, after enabling the interrupts of the individual peripherals, you use one more "global" command to tell the microcontroller that you are ready for the interrupts to start.

To perform this second step, you need to perform the following command, where GIE stands for Global Interrupt Enable bit: _BIS_SR(GIE);

_BIS_SR is a special function developed by Texas Instruments specifically to set bits (BIt Set) int the Status Register.

The only thing we have left to do is create the interrupt service rountine function itself:

#pragma vector=TIMER0_A0_VECTOR

__interrupt void Timer0_ISR (void) {
	
}

The first line of the ISR must always look like this: #pragma vector=TIMER0_A0_VECTOR

Because ISRs are so special, they must be placed in very exact locations in program memory. This instruction ensures that the Timer0 ISR is placed properly.

The second line of code of the ISR is where you specify the function you are creating is an ISR and you give it a name. We saw that we could omit the void labels for the input and output type. However, omitting them in an interrupt service rountine will generate an error.

Status Register Bits
GIE - Bit 3 - General interrupt enable. When set, enables maskable interrupts. When reset, all maskable interrupts are disabled.

As diretivas pragma especificam recursos de compilador específicos ao sistema (no caso, especificos ao sistema microcontrolado).

In the past, we always had to make sure that we cleared the TAIFG flag in the TA0CTL register after the timer elapsed. This is automatically included by ccs withe the TIMER0_A0_VECTOR ISR.

If the LED is off for 45,000 count (TAxCCRn value), and it is on for 5,000 count, it will be on approximately 10% of the time (5,000 / (45,000 + 5,000)). We say that the output has a 10% duty cycle.

Two interrupt vectors are associated with the 16-bit Timer_A module:
• TACCR0 interrupt vector for TACCR0 CCIFG
• TAIV interrupt vector for all other CCIFG flags and TAIFG

The TACCR1 CCIFG, TACCR2 CCIFG, and TAIFG flags are prioritized and combined to source a single interrupt vector. The interrupt vector register TAIV is used to determine which flag requested an interrupt.

The highest priority enabled interrupt generates a number in the TAIV register (see register description). This number can be evaluated or added to the program counter to automatically enter the appropriate software routine. Disabled Timer_A interrupts do not affect the TAIV value. Any access, read or write, of the TAIV register automatically resets the highest pending interrupt flag. If another interrupt flag is set, another interrupt is immediately generated after servicing the initial interrupt. For example, if the TACCR1 and TACCR2 CCIFG flags are set when the interrupt service routine accesses the TAIV register, TACCR1 CCIFG is reset automatically. After the RETI instruction of the interrupt service routine is executed, the TACCR2 CCIFG flag will generate another interrupt.

TAIV, Timer_A Interrupt Vector Register

TAIVx - Bits 3-1:
00h No interrupt pending
02h Capture/compare 1 TACCR1 CCIFG	Highest
04h Capture/compare 2 TACCR2 CCIFG
06h Reserved
08h Reserved
0Ah Timer overflow TAIFG
0Ch Reserved
0Eh Reserved				Lowest


Timer_A control TACTL
Timer_A counter TAR
Timer_A capture/compare control 0 TACCTL0
Timer_A capture/compare 0 TACCR0
Timer_A capture/compare control 1 TACCTL1
Timer_A capture/compare 1 TACCR1
Timer_A capture/compare control 2 TACCTL2(1)
Timer_A capture/compare 2 TACCR2(1)
Timer_A interrupt vector TAIV

Pulse-Width Modulation (PWM) means turning on/off a digital output with set percentages of time and that pulse width modulation can be useful for driving some outputs.

